#!/usr/bin/env ruby

require 'net/ssh'

class App
  def self.run(host)
    new(host)
  end
  
  def initialize(host, user = nil)
    log "hi"
    @host = host
    @user = user
    Net::SSH.start(@host, @user) do |ssh|
      check
      upload_recipes(ssh)
      run(ssh)
    end
    log "bye"
  end
  
  def check
    if !File.exist?('cookbooks')
      raise "not in chef cookbooks project need to be in one"
    end
  end
  def upload_recipes(ssh)
    @file_cache_path = "/tmp/chef-solo"
    @recipes_path = "/tmp/chef-solo/recipes"
    # create
    local_exec("tar czf recipes.tgz .")
    # upload
    local_exec("scp recipes.tgz #{@host}:")
    # move
    log "removing current chef recipes : #{@recipes_path}"
    ssh_exec(ssh, "rm -rf #{@recipes_path}")
    log "extracting new chef recipes"
    ssh_exec(ssh, "mkdir #{@recipes_path}")
    ssh_exec(ssh, "tar -zxf recipes.tgz -C #{@recipes_path}")
  end
  
  def run(ssh)
    ssh_exec(ssh, "chef-solo -c ~/solo.rb -j ~/dna.json")
  end
  
private
  def log(msg)
    puts msg
  end
  def local_exec(command)
    log `#{command}`
  end
  def ssh_exec(ssh, command)

    unless ARGV.empty?
      log "Executing command: #{command}"
    end

    stdout = ""
    ssh.exec!(command) do |channel, stream, data|
      stdout << data if stream == :stdout
    end
    output = stdout

    # output = ssh.exec!(command)

    if output
      log "Output: #{output}"
    end

    output
  end
end

server = ARGV[1]
if server.nil? or server == ""
  raise "Usage: runchef <server-name>"
end
App.run(server)


# Net::SSH.start('host', 'user', :password => "password") do |ssh|
#   # capture all stderr and stdout output from a remote process
#   output = ssh.exec!("hostname")
# 
#   # capture only stdout matching a particular pattern
#   stdout = ""
#   ssh.exec!("ls -l /home/jamis") do |channel, stream, data|
#     stdout << data if stream == :stdout
#   end
#   puts stdout
# 
#   # run multiple processes in parallel to completion
#   ssh.exec "sed ..."
#   ssh.exec "awk ..."
#   ssh.exec "rm -rf ..."
#   ssh.loop
# 
#   # open a new channel and configure a minimal set of callbacks, then run
#   # the event loop until the channel finishes (closes)
#   channel = ssh.open_channel do |ch|
#     ch.exec "/usr/local/bin/ruby /path/to/file.rb" do |ch, success|
#       raise "could not execute command" unless success
# 
#       # "on_data" is called when the process writes something to stdout
#       ch.on_data do |c, data|
#         $STDOUT.print data
#       end
# 
#       # "on_extended_data" is called when the process writes something to stderr
#       ch.on_extended_data do |c, type, data|
#         $STDERR.print data
#       end
# 
#       ch.on_close { puts "done!" }
#     end
#   end
# 
#   channel.wait
# 
#   # forward connections on local port 1234 to port 80 of www.capify.org
#   ssh.forward.local(1234, "www.capify.org", 80)
#   ssh.loop { true }
# end